# 플로이드–워셜(Floyd-Warshall)

## 플로이드-워셜 알고리즘

> 모든 노드에서 다른 모든 노드까지의 최단 경로를 구하는 알고리즘이다.   
다익스트라 알고리즘과 다르게 DP알고리즘에 속한다.
> 

## 플로이드-워셜 알고리즘 원리

모든 노드에 대하여 각 노드를 거치는 경우의 최단거리를 계산하여 테이블을 갱신하는 방식이다.   
k번째 노드를 고려하여, a,b사이의 최단거리를 갱신하면 다음과 같다.   
- D<sub>ab</sub> (a에서 b로 가는 최단 거리) = min(D<sub>ab</sub>, D<sub>ak</sub> + D<sub>kb</sub>)   

아래와 같은 그래프가 있을 때, 각 노드에서 다른 노드들 까지의 최단 거리를 알아보자.   

![algorithm-thisiscote-07-1643245004239](https://user-images.githubusercontent.com/87896466/170947835-aa8151d3-18dc-4def-86d9-220576544066.png)

1. 초기 테이블을 설정한다.

| 출발/도착 | 1 | 2 | 3 | 4 |
| --- | --- | --- | --- | --- |
| 1 | 0 | 4 | 무한 | 6 |
| 2 | 3 | 0 | 7 | 무한 |
| 3 | 5 | 무한 | 0 | 4 |
| 4 | 무한 | 무한 | 2 | 0 |
2. 각각의 노드들을 거쳐가는 경우에 대하여 테이블을 갱신한다.   
 - 1번 노드에 대하여 갱신하면 다음과 같다.   
    ex) DP24 = min(DP24, DP21 + DP14)   
    
    | 출발/도착 | 1 | 2 | 3 | 4 |
    | --- | --- | --- | --- | --- |
    | 1 | 0 | 4 | 무한 | 6 |
    | 2 | 3 | 0 | 7 | 9 |
    | 3 | 5 | 9 | 0 | 4 |
    | 4 | 무한 | 무한 | 2 | 0 |
    
 - 2번 노드에 대하여 갱신하면 다음과 같다.
    
    | 출발/도착 | 1 | 2 | 3 | 4 |
    | --- | --- | --- | --- | --- |
    | 1 | 0 | 4 | 11 | 6 |
    | 2 | 3 | 0 | 7 | 9 |
    | 3 | 5 | 9 | 0 | 4 |
    | 4 | 무한 | 무한 | 2 | 0 |
    
 - 3번 노드에 대하여 갱신하면 다음과 같다.
    
    | 출발/도착 | 1 | 2 | 3 | 4 |
    | --- | --- | --- | --- | --- |
    | 1 | 0 | 4 | 11 | 6 |
    | 2 | 3 | 0 | 7 | 9 |
    | 3 | 5 | 9 | 0 | 4 |
    | 4 | 7 | 11 | 2 | 0 |
    
 - 4번 노드에 대하여 갱신하면 다음과 같다.
    
    | 출발/도착 | 1 | 2 | 3 | 4 |
    | --- | --- | --- | --- | --- |
    | 1 | 0 | 4 | 8 | 6 |
    | 2 | 3 | 0 | 7 | 9 |
    | 3 | 5 | 9 | 0 | 4 |
    | 4 | 7 | 11 | 2 | 0 |
3. 결과

| 출발/도착 | 1 | 2 | 3 | 4 |
| --- | --- | --- | --- | --- |
| 1 | 0 | 4 | 8 | 6 |
| 2 | 3 | 0 | 7 | 9 |
| 3 | 5 | 9 | 0 | 4 |
| 4 | 7 | 11 | 2 | 0 |

> 노드의 개수를 N이라 하면, 각 노드에 대하여 탐색이 진행되므로 N번의 단계를 수행한다.    
또한, 각 단계마다 ‘현재 노드를 거쳐가는 모든 경로’를 고려하는 O(N<sup>2</sup>)의 연산을 하게 된다.   
따라서 플로이드-워셜 알고리즘은 O(N<sup>3</sup>)의 시간복잡도를 가진다.
> 

## 플로이드-워셜 알고리즘 구현

```python
import sys

N, M = map(int, sys.stdin.readline().split())

graph = [[10000]*(N+1) for _ in range(N+1)]
for k in range(1, N+1):
	graph[k][k] = 0
for _ in range(M):
	n1, n2, cost = map(int, sys.stdin.readline().split())
	graph[n1][n2] = cost

for k in range(1, N+1):
	for i in range(1, N+1):
		for j in range(1, N+1):
			graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])

for row in range(1, N+1):
	print(*distance[1:], sep = ' ')
```


🔑 input   
4 7   
1 2 4   
1 4 6   
2 1 3   
2 3 7   
3 1 5   
3 4 4   
4 3 2   
output   
0 4 8 6   
3 0 7 9   
5 9 0 4   
7 11 2 0   
